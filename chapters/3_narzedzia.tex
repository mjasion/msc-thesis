\chapter{Narzędzia wykorzystane do przeprowadzenia testów}

\section{Docker}
Docker jest platforma dla programistów i administratorów systemóœ do tworzenia, dostarczania i uruchamiania aplikacji. Docker pozwala zbudować aplikację z zależnościami, która zachowywać się będzie tak samo na środowisku produkcyjnym jak i programistycznym. Dzieje się tak, ponieważ budując aplikację tworzymy obrazy, które po zbudowaniu przenosimy na docelowe środowisko.\\*
Docker opiera się na kontenerach linuxowych(LXC - Linux Containers). Kontenery w Linuxie są wirtualizacją na poziome systemu operacyjnego, która umożliwia na separacje aplikacji od systemu operacyjnego i fizycznej infrastruktury wykorzystywanej m.in. do połączeń sieciowych czy plików. Każdy z kontenerów może uruchomić swój proces, może mieć własnych użytkowników. Kontenerów w jednym systemie może być uruchomiona nieograniczona ilość. Konteneryzacja w przeciwieństwie do wirtualizacji  oferuje niewielki narzut na zasoby. Uruchomienie pojedynczego kontenera ogranicza się do wykonania kilku standardowych poleceń systemowych. 
Dla niniejszej pracy użyto Docker w wersji 1.9.0.

\section{MongoDB}
MongoDB(https://www.mongodb.org/) jest nierelacyjną bazą danych(ang. \textsl{NoSQL database}). Główną cechą tej bazy jest brak ściśle zdefiniowanej struktury. Dane w bazie przechowywane są w postaci dokumentów. Dokument jest niczym innym jak obiektem typu \textsl{JSON}. Sama baza jednak przechowuje dokumenty w formie binarnej, w skrócie nazywanego \textsl{BSON} (\textsl{Binary JSON}). Dokument sam w sobie jest strukturą złożoną z par klucz-wartość. Wartości w dokumencie mogą być cyframi, napisami, wartościami logicznymi(\textsl{boolean}), tablicami, jak również mogą zagnieżdżać inne dokumenty czy tablice dokumentów. Pojedyncze dokumenty przechowywane są w kolekcji. Kolekcja natomiast musi należeć do określonej bazy.

Każdy dokument w kolekcji musi mieć swój identyfikator, który w kolekcji musi być unikalny. Kluczem w dokumencie, oznaczającym identyfikator jest \textsl{\_id}. To po identyfikatorze można zmienić pojedynczy dokument. Jeśli zapisywany dokument nie będzie zawierał identyfikatora, baza danych sama wypełni to swoim własnym. Identyfikatory są indeksowane co umożliwia przyspieszyć operacje na dokumentach. Projektanci bazy ograniczyli rozmiar pojedynczego dokumentu do \textsl{16MB}. Oznacza to, że do przechowywania większych plików trzeba zastosować inne rozwiązanie.

Na przykładzie \ref{lst:mongodocument} zaprezentowany jest przykładowy dokument, który zapisany jest w bazie \textsl{MongoDB}

\begin{lstlisting}[language=JavaScript,caption=Przykład dokumentu zapisanego w bazie MongoDB,label={lst:mongodocument}]
{
    _id: ObjectId("5099803df3f4948bd2f98391"),
    name: { 
        first: "Jan", 
        last: "Kowalski" 
    },
    birth: new Date('Jan 01, 1970'),
    email: "jan@kowalski.pl"
}
\end{lstlisting}

Jak wcześniej zostało wspomniane \textsl{MongoDB} kolekcje nie posiadają zdefiniowanej struktury. Oznacza to, że w kolekcji można zapisać dwa dokumenty, gdzie jedynym wspólnym kluczem będzie \textsl{\_id}. Również w kolekcji mogą się znaleźć dokumenty, które temu samemu polu przypiszą wartości dwóch różnch typów np. boolean i string. Indeksy na kolekcji są bardzo zbliżone do tych, znanych z baz relacyjnych. Administrator może założyć indeks unikalny i nieunikalny, na jedną lub więcej kolumn. Dzięki założonemu indeksowi czas wyszukiwania dokumentów znacząco spadnie

W porównaniu do baz relacyjnych dokumenty nie mogą posiadać relacji innych niż zagnieżdżenia. Kolejną różnicą jest brak transakcji. W \textsl{MongoDB} nie można wykonać zbioru poleceń. Również zasada atomowości różni się od tej z baz relacyjnych. Jeśli przeprowadzana jest pojedyncza zmiana wielu dokumentów, to zmiana może się udać w całości lub wcale na pojedynczym dokumencie, a nie całym zbiorze, których dotyczy. Brak tych elementów pozwolił na zachowanie wysokiej wydajności, gdy baza składa się z wielu węzłów.

\textsl{MongoDB} znalazł zastosowanie wśród projektów operujących na dużej ilości danych(\textsl{Big Data}). Dzięki prostej konfiguracji można uruchomić instancje bazy na wielu węzłach by zabezpieczyć dane przed utratą. Baza posiada wiele funkcji agregujących, pozwalających na analizę zapisanych danych na wielu węzłach równocześnie. 

Do testów w pracy użyto bazę \textsl{MongoDB} w wersji \textsl{3.0}.


\section{Apache JMeter}
\textsl{Apache JMeter}(http://jmeter.apache.org/) jest programem służącym do wykonywania testów aplikacji w celu zmierzenia jej wydajności.  Początkowo został stworzony do tworzenia testów serwisów internetowych. Jednak z czasem został on rozszerzony o dodatkowe funkcje. \textsl{Apache JMeter} można użyć do symulowania wysokiego obciążenia aplikacji na serwerze, sieci lub innych testowanych obiektach.
Obecnie \textsl{Apache JMeter} można zastosować do testowania serwerów i protokołów:
\begin{itemize}
\item HTTP
\item HTTPS
\item FTP
\item SOAP oraz REST
\item relacyjne bazy danych - przy użyciu sternika JDBC
\item nierelacyjne bazy danych np MongoDB
\item usług pocztowych wykorzstujących protokoły: SMTP, POP3 oraz IMAP
\item TCP
\end{itemize}

\textsl{Apache JMeter} można rozszerzać o własne pluginy więc lista usług dostępnych do testowania jest nieograniczona. \textsl{Apache JMeter} jest wielowątkowym narzędziem, przez co można wykonywać ten sam test rówlnolegle, symulując w ten sposób wielu urzytkowników. 

% TODO Jak tworzyć testy
Pierwsza stabilna wersja Apache JMeter została wydana 15 grudnia 1998r. Dla testów w pracy użyto wersji 2.13, która została wydana 14 marca 2015r.

\section{Digitalocean}
Digitalocean(https://www.digitalocean.com/) jest usługą, pozwalającą na zakup wirtualnych serwerów w tzw. chmurze. Chmura wykorzystuje model \textsl{Infrastructure as a Service}(skrót: \textsl{IAAS}, z ang. infrastruktura jako usługa"), dzięki której klient może kupić zasoby sprzętowe(dysk, procesor, łącze, pamięć ram) w zależności od potrzeb i budżetu. Zaletą takiego modelu dla klientów jest możliwość zakupu, tylko wtedy gdy dana usługa jest potrzeba. Kolejną zaletą jest możliwość dostosowania potrzebnych zasobów w zależności od obciążenia aplikacji.