\textsl{REST} (ang. \textsl{REpresentational State Transfer}) jest stylem architektonicznym oprogramowania dla rozproszonych systemów hipermedialnych. W 2000 roku opisał go Roy Thomas Fielding w swojej pracy doktorskiej zatytułowanej \textsl{''Architectural Styles and te Design of Network-based Software Architectures"} \cite{restinpractice}.

Roy Fielding badając  szybki rozwój sieci \textsl{Internet} przedstawił różne style architektoniczne, które przyczyniły się do szybkiego rozwoju m.in. sieci \textsl{WWW} (ang. \textsl{World Wide Web}). Za źródło sukcesu  uważał rozproszenie systemu oraz to jak poszczególne zasoby sieci ze sobą się łączyły. Był on również współautorem protokołu \textsl{HTTP/1.0}. Na podstawie zdobytych doświadczeń zaproponował nowy styl  architektury nadając mu nazwę \textsl{REpresentational State Transfer} w skrócie \textsl{REST}.  

Styl \textsl{REST} jest  zgodny z architekturą sieci \textsl{WWW}. Opisuje on sieć \textsl{WWW} jako rozproszony zbiór aplikacji, wykorzystujących \textsl{hypermedia} czyli dane będące powiązaniem grafiki, dźwięku, wideo, tekstu oraz \textsl{hyperlinków}. 

\subsection{Architektura REST}
\textsl{REST} jest hybrydą kilku stylów architektonicznych. Przestrzeganie zasad, które \textsl{REST} wprowadza gwarantuje lepszą wydajność, skalowalność oraz niezawodność tworzonych usług internetowych w tej architekturze. 

\textsl{REST} swoją architekturą łączy kilka wzorców tworzenia aplikacji sieciowych.

Pierwszą z nich jest wzorzec \textsl{klient-serwer} - rozdziela ona rolę serwera i klienta. Rolą serwera jest zapewnienie danych, natomiast rolą klienta jest zgłaszanie się po dane. Klient ma możliwość tworzenia aplikacji wykorzystujących ten sam interfejs, które można uruchomić na różnych systemach. Serwerom daje to możliwość rozwijać swoje interfejsy, niezależnie od klientów. Takie podejście jest wykorzystywane od lat w aplikacjach internetowych.

Kolejnym wzorcem jest bezstanowość (ang. \textsl{stateless}). Opiera się ono na zasadzie, że każde żądanie klienta do serwera musi zawierać informacje potrzebne do zrozumienia tego żądania oraz wygenerowania odpowiedzi. W praktyce oznacza to, że serwer nie przechowuje danych szczególnych klienta w swoim kontekście. Wymusza to na kliencie trzymanie stanu sesji. Dzięki temu pamięć serwera nie jest ograniczana, a jednocześnie pozwala na zwiększenie liczby klientów z którymi może się równocześnie komunikować. Dodatkowo zwiększa to możliwość skalowalność usługi. Zachowanie zasady bezstanowości może powodować, że czasem część danych jest przesyłana nadmiarowo.

Dla poprawy wydajności wykorzystywana jest pamięć podręczną (ang. \textsl{cache}). Klient może przechowywać otrzymane zasoby w pamięci by nie generować niepotrzebnie dwóch takich samych żądań. Wymaga to klasyfikacji zasobów na takie, które nie wymagają częstych odświeżeń. Serwer może poinformować, że zasób może być przechowywany w pamięci oraz na jak długo, czy też nie.  

Kolejną zasadą, którą \textsl{REST} wykosztuje jest architektura warstwowa. Dzięki temu podejściu możliwe jest zhierarchizowanie komponentów systemu, tak by nie nie musiały wiedzieć o systemie więcej, niż to do czego zostały stworzone. W ten sposób, system staje się prostszy do zrozumienia, a poszczególne komponenty mogą być wykorzystywane wielokrotnie.

 \textsl{REST} wymaga zachowania jednolitego interfejsu w komunikacji między komponentami systemu. Każdy zasób powinien być jednoznacznie identyfikowany przy pomocy \textsl{URI} (ang. \textsl{Uniform Resource Identifier}). Możliwe jest modyfikowanie zasobów przez ich reprezentacje - taki sam zasób może zostać zwrócony w różnych formach np. \textsl{XML}, \textsl{JSON} czy zwykły tekst. Zwrócona forma determinuje sposób przetwarzania danych przez klienta. Wykorzystanie  \textsl{hypermediów} jako silnika stanów aplikacji (\textsl{HATEOAS}) pozwala klientowi na przechodzenie między stanami zasobu. Informacje o  zasobach i operacjach na zasobie przesyłane są bezpośrednio do klienta. Dzięki temu klient nie musi mieć wiedzy o wszystkich operacjach na zasobach, żeby z nich korzystać. Jednolity interfejs sprawia, że architektura systemu jest uproszona, a współpraca między komponentami bardziej przejrzysta.
 
 
 


% \newpage
% \subsection{OLD}
% W 2000 roku Roy Thomas Fielding w swojej pracy doktorskiej zatytułowanej \textsl{''Architectural Styles and te Design of Network-based Software Architectures"} badał szybki rozwój sieci \textsl{Internet}. Autor w pracy przedstawił różne style architektoniczne, które przyczyniły się do szybkiego rozwoju m.in. sieci \textsl{WWW}(ang. \textsl{World Wide Web}). Sieć \textsl{WWW} jest zbiorem zasobów i dokumentów, które są połączone ze sobą hiperłączami oraz URLami. Do swojego działania wykorzystuje sieć \textsl{Internet}.  Zdaniem autora źródłem sukcesu sieci \textsl{WWW} było rozproszenie systemu, oraz to jak poszczególne zasoby sieci ze sobą współdziałały\cite{restinpractice}. Roy Thomas Fielding nawiązał do takiej architektury nazywając ją właśnie terminem \textsl{REpresntation State Transfer}. \textsl{REST} opisuje sieć \textsl{WWW} jako rozproszony zbiór aplikacji, wykorzystujących \textsl{hypermedia} czyli dane będące powiązaniem grafiki, dźwięku, wideo, tekstu oraz \textsl{hyperlinków}. 

% \textsl{REST} swoją architekturą łączy kilka wzorców tworzenia aplikacji sieciowych. 

% Pierwszą z nich jest najpopularniejszy wzorzec: klient-serwer. Polega on na podziale ról: serwera i klienta. Rolą serwera w przypadku \textsl{REST} jest zapewnienie danych, natomiast rolą klienta jest zgłaszanie się po dane. Dla klientów do zalet takiego rozwiązania należy zaliczyć możliwość tworzenia aplikacji wykorzystujących ten sam interfejs, które można uruchomić na różnych systemach. Natomiast dla serwerów pozwala to na rozwijanie interfejsów, niezależnie od klientów. Takie podejście jest wykorzystywane od lat w aplikacjach internetowych. 

% Kolejnym wzorcem jest bez stanowość(ang. \textsl{stateless}). Opiera się ono na zasadzie, że każde żądanie z klienta do serwera musi zawierać informacje potrzebne do zrozumienia tego żądania. W praktyce oznacza to, że klient nie może poprosić serwera o przechowanie w swoim kontekście danych szczególnych temu klientowi. Stan sesji musi więc być trzymany po stronie klienta co pozwala na zapewnienie skalowalności. Jednak powoduje ono, że czasem część danych jest przesyłana nadmiarowo.

% W celu poprawy wydajności wykorzystuje się pamięć podręczną(ang. \textsl{cache}). Celem takiego rozwiązania jest, by bez potrzeby nie generować tej samej odpowiedzi dwukrotnie. Pamięć podręczna może zostać zaimplementowana zarówno po stronie klienta jak i serwera.

% Kolejną zasadą, którą \textsl{REST} wykosztuje jest architektura warstwowa. Dzięki temu podejściu możliwe jest zhierarchizowanie komponentów systemu, tak by nie nie musiały wiedzieć o systemie więcej, niż to do czego zostały stworzone. W ten sposób, system staje się prostszy do zrozumienia, a poszczególne komponenty mogą być wykorzystywane wielokrotnie przez inne.

% Rzeczą która odróżnia architekturę \textsl{REST} od innych wzorców aplikacji sieciowych jest nacisk na ujednolicenie interfejsu pomiędzy komponentami. Zastosowanie tej zasady z inżynierii oprogramowania sprawia, że architektura systemu jest uproszona. Przekłada się to na ogólną widoczność interakcji w systemie. 

% W \textsl{REST} 

% \subsection{Budowa usług REST}
% Myśląc
% Pierwszą rzeczą, odróżniającą \textsl{REST} od innych usług sieciowych jest jego niezależność od protokołu którym dane są wymieniane. Dlatego może on zwracać obiekty \textsl{JSON}(ang. \textsl{JavaScript Object Notation}), \textsl{XML}(ang. \textsl{Extensible Markup Language}) czy też po prostu czysty tekst. 

% Do komunikacji z usługami \textsl{REST} wykorzystuje się protokół \textsl{HTTP}(ang. \textsl{Hypertext Transfer Protocol}). Poprzez adresy URL można odwoływać się do zasobów.

% \subsection{REST a RESTful}
% https://stackoverflow.com/questions/671118/what-exactly-is-restful-programming
% \subsection{HATEOAS}
% System taki można określić jako zbiór aplikacji, których stany są przedstawiane unikalnie identyfikowanymi zasobami